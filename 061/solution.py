#! encoding: utf8
from itertools import count
from profile_decorate import profile

"""
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:

Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Square	 	P4,n=n2	 	1, 4, 9, 16, 25, ...
Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
This is the only set of 4-digit numbers with this property.
Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
"""


class Point:
    def __init__(self, type, number):
        self.type = type
        self.left = str(number)[:2]
        self.right = str(number)[2:]
        self.value = number
        self.next = list()


class Pointer:
    def __init__(self, p_type, value):
        self.p_type = p_type
        self.p_value = value


def figurate_generator(p):
    if p == 3:
        return lambda n: n*(n+1)/2
    elif p == 4:
        return lambda n: n*n
    elif p == 5:
        return lambda n: n*(3*n-1)/2
    elif p == 6:
        return lambda n: n*(2*n-1)
    elif p == 7:
        return lambda n: n*(5*n-3)/2
    elif p == 8:
        return lambda n: n*(3*n-2)


@profile
def main():
    graph_set = {
        3: list(),
        4: list(),
        5: list(),
        6: list(),
        7: list(),
        8: list(),
    }
    # generate graph
    for p in range(3, 9):
        p_gen_func = figurate_generator(p)
        for n_now in count(1):
            number = p_gen_func(n_now)
            if number < 1000:
                continue
            elif number > 9999:
                break
            else:
                point_now = Point(number=number, type=p)
                graph_set[p].append(point_now)
                for prev_p in graph_set:
                    if len(graph_set[prev_p]) > 0 and prev_p != p:
                        for idx, p_point in enumerate(graph_set[prev_p]):
                            if p_point.right == point_now.left:
                                graph_set[prev_p][idx].next.append(point_now)
                            if p_point.left == point_now.right:
                                point_now.next.append(p_point)

    def next_point_in_graph(point_now, visited_dict):
        for next_point in point_now.next:
            if next_point.type in visited_dict:
                continue
            else:
                yield next_point

    for point in graph_set[3]:
        visited_dict = dict()
        visited_dict[point.type] = point
        for point2 in next_point_in_graph(point, visited_dict):
            visited_dict[point2.type] = point2
            for point3 in next_point_in_graph(point2, visited_dict):
                visited_dict[point3.type] = point3
                for point4 in next_point_in_graph(point3, visited_dict):
                    visited_dict[point4.type] = point4
                    for point5 in next_point_in_graph(point4, visited_dict):
                        visited_dict[point5.type] = point5
                        for point6 in next_point_in_graph(point5, visited_dict):
                            visited_dict[point6.type] = point6
                            for last_point in point6.next:
                                if last_point.type == point.type and last_point.value == point.value:
                                    print("we have answer {}".format(
                                        ["{} from type {}".format(visited_dict[point].value, visited_dict[point].type)
                                         for point in visited_dict]))
                                    print(
                                    "sum is {}".format(sum([visited_dict[point].value for point in visited_dict])))
                                    return 0
                            visited_dict.pop(point6.type)
                        visited_dict.pop(point5.type)
                    visited_dict.pop(point4.type)
                visited_dict.pop(point3.type)
            visited_dict.pop(point2.type)


if __name__ == '__main__':
    main()
